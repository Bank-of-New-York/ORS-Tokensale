pragma solidity 0.4.23;

import "./ORSToken.sol";
import "../eidoo-icoengine/contracts/ICOEngineInterface.sol";
import "../eidoo-icoengine/contracts/KYCBase.sol";
import "../zeppelin-solidity/contracts/math/SafeMath.sol";
import "../zeppelin-solidity/contracts/ownership/Ownable.sol";


/// @title ORSTokenSale
/// @author Autogenerated from a Dia UML diagram
contract ORSTokenSale is KYCBase, ICOEngineInterface, Ownable {

    using SafeMath for uint;

    uint constant public MAINSALE_CAP = 500000000e18;   // 500,000,000 e18
    uint constant public PRESALE_CAP = 0;               // TBD!
    uint constant public BONUS_CAP = 64460000e18;       //  64,460,000 e18
    uint constant public TEAM_CAP = 83333333e18;        //  83,333,333 e18
    uint constant public COMPANY_CAP = 127206667e18;    // 127,206,667 e18
    uint constant public ADVISORS_CAP = 58333333e18;    //  58,333,333 e18

    uint public CAP = MAINSALE_CAP + PRESALE_CAP + BONUS_CAP + TEAM_CAP + COMPANY_CAP + ADVISORS_CAP;

    uint public mainsaleRemaining = MAINSALE_CAP;
    uint public presaleRemaining = PRESALE_CAP;
    uint public bonusRemaining = BONUS_CAP;

    address public teamWallet;
    address public companyWallet;
    address public advisorsWallet;

    ORSToken public token;

    uint public rate;  // integral token units (10^-18 tokens) per wei

    uint public openingTime;
    uint public closingTime;

    address public wallet;

    address public eidooSigner;

    bool public isFinalized = false;

    /// @dev Log entry on rate changed
    /// @param newRate A positive number
    event RateChanged(uint newRate);

    /// @dev Log entry on token purchased
    /// @param buyer An Ethereum address
    /// @param value A positive number
    /// @param tokens A positive number
    event TokenPurchased(address indexed buyer, uint value, uint tokens);

    /// @dev Log entry on buyer refunded
    /// @param buyer An Ethereum address
    /// @param value A positive number
    event BuyerRefunded(address indexed buyer, uint value);

    /// @dev Log entry on finalized
    event Finalized();

    /// @dev Constructor
    /// @param _token An ORSToken
    /// @param _rate A positive number
    /// @param _openingTime A positive number
    /// @param _closingTime A positive number
    /// @param _wallet An Ethereum address
    /// @param _teamWallet An Ethereum address
    /// @param _companyWallet An Ethereum address
    /// @param _advisorsWallet An Ethereum address
    /// @param _kycSigners A list where each entry is an Ethereum address
    constructor(
        ORSToken _token,
        uint _rate,
        uint _openingTime,
        uint _closingTime,
        address _wallet,
        address _teamWallet,
        address _companyWallet,
        address _advisorsWallet,
        address[] _kycSigners
    )
        public
        KYCBase(_kycSigners)
    {
        require(_token != address(0x0));
        //require(_token.cap() == MAINSALE_CAP + PRESALE_CAP + BONUS_CAP + TEAM_CAP + COMPANY_CAP + ADVISORS_CAP);
        //require(uint(_token.cap()) > uint(CAP));
        require(833333333000000000000000000 == _token.cap());
        require(_rate > 0);
        require(_openingTime > now && _closingTime > _openingTime);
        require(_wallet != address(0x0));
        require(_teamWallet != address(0x0) && _companyWallet != address(0x0) && _advisorsWallet != address(0x0));
        require(_kycSigners.length >= 2);

        token = _token;
        rate = _rate;
        openingTime = _openingTime;
        closingTime = _closingTime;
        wallet = _wallet;
        teamWallet = _teamWallet;
        companyWallet = _companyWallet;
        advisorsWallet = _advisorsWallet;

        eidooSigner = _kycSigners[0];
    }

    /// @dev Set rate
    /// @param newRate A positive number
    function setRate(uint newRate) public onlyOwner {
        require(newRate > 0);

        if (newRate != rate) {
            rate = newRate;

            emit RateChanged(newRate);
        }
    }

    /// @dev Distribute presale
    /// @param investors A list where each entry is an Ethereum address
    /// @param tokens A list where each entry is a positive number
    /// @param bonuses A list where each entry is a positive number
    function distributePresale(address[] investors, uint[] tokens, uint[] bonuses) public onlyOwner {
        require(ended() && !isFinalized);
        require(investors.length == tokens.length && bonuses.length == tokens.length);

        for (uint i = 0; i < investors.length; ++i) {
            presaleRemaining = presaleRemaining.sub(tokens[i]);
            bonusRemaining = bonusRemaining.sub(bonuses[i]);

            token.mint(investors[i], tokens[i].add(bonuses[i]));
        }
    }

    /// @dev Started
    /// @return True or false
    function started() public view returns (bool) {
        return now > openingTime;
    }

    /// @dev Ended
    /// @return True or false
    function ended() public view returns (bool) {
        return now > closingTime || mainsaleRemaining == 0;
    }

    // time stamp of the starting time of the ico, must return 0 if it depends on the block number
    /// @dev Start time
    /// @return A positive number
    function startTime() public view returns (uint) {
        return openingTime;
    }

    // time stamp of the ending time of the ico, must retrun 0 if it depends on the block number
    /// @dev End time
    /// @return A positive number
    function endTime() public view returns (uint) {
        return closingTime;
    }

    // returns the total number of the tokens available for the sale, must not change when the ico is started
    /// @dev Total tokens
    /// @return A positive number
    function totalTokens() public view returns (uint) {
        return MAINSALE_CAP;
    }

    // returns the number of the tokens available for the ico. At the moment that the ico starts it must be
    // equal to totalTokens(), then it will decrease. It is used to calculate the percentage of sold tokens as
    // remainingTokens() / totalTokens()
    /// @dev Remaining tokens
    /// @return A positive number
    function remainingTokens() public view returns (uint) {
        return mainsaleRemaining;
    }

    // return the price as number of tokens released for each ether
    /// @dev Price
    /// @return A positive number
    function price() public view returns (uint) {
        return rate;
    }

    /// @dev Finalize
    function finalize() public onlyOwner {
        require(ended() && !isFinalized);
        require(presaleRemaining == 0);

        token.mint(teamWallet, TEAM_CAP);
        token.mint(companyWallet, COMPANY_CAP);
        token.mint(advisorsWallet, ADVISORS_CAP);

        if (bonusRemaining > 0) {
            token.mint(companyWallet, bonusRemaining);
        }

        token.finishMinting();
        token.unpause();
        token.transferOwnership(owner);

        isFinalized = true;

        emit Finalized();
    }

    /// @dev Release tokens to
    /// @param buyer An Ethereum address
    /// @param signer An Ethereum address
    /// @return True or false
    function releaseTokensTo(address buyer, address signer) internal returns (bool) {
        require(started() && !ended());

        uint value = msg.value;
        uint refund = 0;

        uint tokens = value.mul(rate);
        uint bonus = 0;

        if (tokens > mainsaleRemaining) {
            uint valueOfRemaining = mainsaleRemaining.div(rate);

            refund = value.sub(valueOfRemaining);
            tokens = mainsaleRemaining;
            value = valueOfRemaining;
            // Note:
            // To be 100% accurate the buyer should have received only the token amount that
            // correspondents to valueOfRemaining, i.e. tokens = valueOfRemaining.mul(rate)...,
            // because of mainsaleRemaining may not be a multiple of rate.
            // Nevertheless, we deliver all mainsaleRemaining as the worth of these additional
            // tokens (amount < rate) is less than a wei.
        }

        if (signer == eidooSigner) {
            bonus = tokens.div(20);
        }

        mainsaleRemaining = mainsaleRemaining.sub(tokens);
        bonusRemaining = bonusRemaining.sub(bonus);

        token.mint(buyer, tokens.add(bonus));
        wallet.transfer(value);
        if (refund > 0) {
            buyer.transfer(refund);

            emit BuyerRefunded(buyer, refund);
        }

        emit TokenPurchased(buyer, value, tokens);

        return true;
    }

}
