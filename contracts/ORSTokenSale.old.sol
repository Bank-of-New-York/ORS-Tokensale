pragma solidity 0.4.23;

import "./ORSToken.sol";
import "../eidoo-icoengine/contracts/ICOEngineInterface.sol";
import "../eidoo-icoengine/contracts/KYCBase.sol";
import "../zeppelin-solidity/contracts/math/SafeMath.sol";
import "../zeppelin-solidity/contracts/ownership/Ownable.sol";


/// @title ORSTokenSale
/// @author Autogenerated from a Dia UML diagram
contract ORSTokenSale is KYCBase, /* ICOEngineInterface, */ Ownable {

    using SafeMath for uint;

    ORSToken public token;
    uint public totalTokens;
    uint public remainingTokens;
    uint public teamShare;
    uint public price;
    uint public startTime;
    uint public endTime;
    uint public weiRaised = 0;
    address public wallet;
    address public teamWallet = 0x0;
    address public eidooWalletSigner;
    bool public isFinalized = false;

    /// @dev Log entry on price changed
    /// @param newPrice A positive number
    event PriceChanged(uint newPrice);

    /// @dev Log entry on token purchased
    /// @param sender An Ethereum address
    /// @param buyer An Ethereum address
    /// @param value A positive number
    /// @param tokens A positive number
    event TokenPurchased(address indexed sender, address indexed buyer, uint value, uint tokens);

    /// @dev Log entry on buyer refunded
    /// @param sender An Ethereum address
    /// @param buyer An Ethereum address
    /// @param value A positive number
    event BuyerRefunded(address indexed sender, address indexed buyer, uint value);

    /// @dev Log entry on finalized
    event Finalized();

    /// @dev Constructor
    /// @param _token An ORSToken
    /// @param _totalTokens A positive number
    /// @param _teamShare A positive number
    /// @param _price A positive number
    /// @param _startTime A positive number
    /// @param _endTime A positive number
    /// @param _wallet An Ethereum address
    /// @param _kycSigners A list where each entry is an Ethereum address
    constructor(
        ORSToken _token,
        uint _totalTokens,
        uint _teamShare,
        uint _price,
        uint _startTime,
        uint _endTime,
        address _wallet,
        address[] _kycSigners
    )
        public
        KYCBase(_kycSigners)
    {
        //require(_token != address(0x0));
        require(_totalTokens > 0 && _totalTokens <= _token.cap().sub(_teamShare));
        require(_price > 0);
        require(_startTime >= now && _endTime >= _startTime);
        require(_wallet != address(0x0));
        require(_kycSigners.length >= 1);

        token = _token;
        totalTokens = _totalTokens;
        remainingTokens = _totalTokens;
        teamShare = _teamShare;
        price = _price;
        startTime = _startTime;
        endTime = _endTime;
        wallet = _wallet;
        eidooWalletSigner = _kycSigners[0];
    }

    /// @dev Set price
    /// @param _price A positive number
    function setPrice(uint _price) public onlyOwner {
        require(_price > 0);

        if (_price != price) {
            price = _price;

            emit PriceChanged(_price);
        }
    }

    /// @dev Set team wallet
    /// @param _teamWallet An Ethereum address
    function setTeamWallet(address _teamWallet) public onlyOwner {
        require(_teamWallet != address(0x0));

        teamWallet = _teamWallet;
    }

    /// @dev Distribute presale
    /// @param _investors A list where each entry is an Ethereum address
    /// @param _tokens A list where each entry is a positive number
    function distributePresale(address[] _investors, uint[] _tokens) public onlyOwner {
        require(ended() && !isFinalized);
        require(_investors.length == _tokens.length);

        for (uint i = 0; i < _investors.length; ++i) {
            require(token.totalSupply().add(_tokens[i]) <= token.cap().sub(teamShare));  // Ugly!
            token.mint(_investors[i], _tokens[i]);
        }
    }

    /// @dev Started
    /// @return True or false
    function started() public view returns (bool) {
        return now > startTime;
    }

    /// @dev Ended
    /// @return True or false
    function ended() public view returns (bool) {
        return now > endTime || remainingTokens == 0; //< price;
    }

    /// @dev Finalize
    function finalize() public onlyOwner {
        require(ended() && !isFinalized);
        require(teamWallet != address(0x0));

        token.mint(teamWallet, teamShare);
        token.finishMinting();
        token.unpause();
        //token.transferOwnerShip(owner)
        isFinalized = true;

        emit Finalized();
    }

    /// @dev Release tokens to
    /// @param buyer An Ethereum address
    /// @return True or false
    function releaseTokensTo(address buyer) internal returns (bool) {
        require(started() && !ended());

        uint value = msg.value;
        uint refund = 0;
        uint tokens = msg.sender == eidooWalletSigner
                      ? value.mul(price).mul(105).div(100)
                      : value.mul(price);

        if (tokens > remainingTokens) {
            uint remainingValue = msg.sender == eidooWalletSigner
                                  ? remainingTokens.mul(100).div(105).div(price)
                                  : remainingTokens.div(price);

            refund = value.sub(remainingValue);
            tokens = remainingTokens;
            value = remainingValue;
            // Note:
            // To be 100% accurate the buyer should have received only the token amount that
            // correspondents to remainingValue, i.e. tokens = remainingValue.mul(price)...,
            // because of remaingTokens may not be a multiple of price.
            // Nevertheless, we deliver all remainingTokens as the worth of these additional
            // tokens (amount < price) is less than a wei.
        }

        weiRaised = weiRaised.add(value);
        remainingTokens = remainingTokens.sub(tokens);

        token.mint(buyer, tokens);
        wallet.transfer(value);
        if (refund > 0) {
            buyer.transfer(refund);

            emit BuyerRefunded(msg.sender, buyer, refund);
        }

        emit TokenPurchased(msg.sender, buyer, value, tokens);

        return true;
    }

}
